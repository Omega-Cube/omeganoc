#!/usr/bin/env python

# Copyright Omega Noc (C) 2014 Omega Cube and contributors
# Xavier Roger-Machart, xrm@omegacube.fr
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This file is part of Omega Noc

import sqlite3
import logging

class PredictReader(object):
    """ This class provides tools used to read the results generated by the prediction algorithms """
    
    def __init__(self, dbpath):
        """ Initializes a new data provider, using the specified file as a data source """
        self.dbpath = dbpath
        
    def __opendb(self):
        result = sqlite3.connect(self.dbpath)
        result.row_factory = sqlite3.Row
        return result
        
    def __checktable(self, con, tablename):
        cur = con.cursor()
        cur.execute("SELECT name from sqlite_master WHERE type='table' AND name=?", (tablename,))
        return cur.fetchone() is not None
        
    def __checkavailability(self, module):
        try:
            with self.__opendb() as con:
                if not self.__checktable(con, 'onoc_pred_versions'):
                    return None
                cur = con.cursor()
                cur.execute('SELECT version FROM onoc_pred_versions WHERE worker_name=?', (module,))
                row = cur.fetchone()
                if row is None:
                    return None
                else:
                    return row[0]
        except sqlite3.OperationalError as ex:
            logging.error('An error occured while opening the prediction database. This usually means that the database file exists, but cannot be accessed by this process.')
            logging.error('Database file path is "{0}"'.format(self.dbpath))
            logging.error(str(ex))
            return None
        
        
    def forecast(self, target):
        """
        Returns the predicted evolution of a value over the next few hours
        
        The target argument should contain the name of a Graphite complnent
        
        If this function returns None, it means that this probe was never checked by the prediction engine (or does not exist)
        Otherwise, it returns a dict containing a date (for the time at which the prediction algorithm was run for the last time) 
        and a 'values' dict. This values dict contains the predicted values: keys are timestamps (they may be in the past if 
        the prediction system did not run for long enough), and values contain the following tuple: (lower 80, lower 95, mean, upper 95, upper 80)
        where the 'mean' value is the actual predicted value, and the 'upper' and 'lower' values indicate the confidence level
        for this prediction. For example, a 'lower 95' value of 0.5 means that there is a 95% chance of having a value above 0.5
        
        Note that in some cases the existing data is not good enough to make any prediction; in that case, the values will be an empty dict.
        """
        with self.__opendb() as con:
            if not self.__checktable(con, 'timewindow'):
                return None
            
            cur = con.cursor()
            cur.execute('SELECT update_time, start_time, step, mean, lower_80, lower_95, upper_80, upper_95 FROM timewindow WHERE probe=?', (target,))
            row = cur.fetchone()
            if row is None:
                return None

            results = {
                'date': int(row['update_time']),
                'values': {},
            }
                
            if row['mean'] is None:
                return results
                
            mean = [float(i) for i in row['mean'].split(';')]
            lower_80 = [float(i) for i in row['lower_80'].split(';')]
            lower_95 = [float(i) for i in row['lower_95'].split(';')]
            upper_80 = [float(i) for i in row['upper_80'].split(';')]
            upper_95 = [float(i) for i in row['upper_95'].split(';')]
            
            t = int(row['start_time'])
            step = int(row['step'])
            for i in xrange(len(mean)):
                results['values'][t] = (
                    lower_80[i],
                    lower_95[i],
                    mean[i],
                    upper_95[i],
                    upper_80[i])
                t += step
            return results
    
    def forecast_available(self):
        return self.__checkavailability('timewindow')
    
    def ranges(self, target):
        """
        Gets the ranged estimates done on a specific element.
        
        The target argument should contain the name of a Graphite component
        
        This gives an estimated chance of having a value in the near future that is located in specific ranges.
        For example, for a CPU this could hint that there is 75% chance of having values between 0 and 50%
        load, 10% chaance to be between 50% and 80% and 15% to be between 80% and 100%
        
        If the specified target was never processed by the prediction engine, or does not exist, the function returns None
        
        The returned value is a dict, containing a 'date' key (with the date of the data for value), and a 'values' key containing
        the intervals array. Each interval in the array is a dict with the following keys :
        - 'from' and 'to' defines the lower and upper value bounds for the interval
        - 'estimate' contains the percentage of chance of having values in the interval (between 0.0 and 1.0)
        
        The returned dict also contains the 'lower_95' and 'upper_95' values which contains the upper and lower bounds of the 95% confidence band
        """
        with self.__opendb() as con:
            if not self.__checktable(con, 'ecdf'):
                return None
            
            cur = con.cursor()
            cur.execute('SELECT update_time, intervals, probabilities, lower_95, upper_95 FROM ecdf WHERE probe=?', (target,))
            row = cur.fetchone()
            if row is None:
                return None
            
            result = {
                'date': int(row['update_time']),
                'values': [],
                'lower_95': 0.0,
                'upper_95': 0.0,
            }
            
            if row['intervals'] is None:
                return result
                
            intervals = [float(i) for i in row['intervals'].split(';')]
            probabilities = [float(i) for i in row['probabilities'].split(';')]
            result['lower_95'] = float(row['lower_95'])
            result['upper_95'] = float(row['upper_95'])
            
            val = 0
            for i in xrange(len(intervals)):
                result['values'].append({
                    'from': val,
                    'to': intervals[i],
                    'estimate': probabilities[i],
                })
                val = intervals[i]
                
            return result
            
    def ranges_available(self):
        return self.__checkavailability('ecdf')
            
    def changes_to_error(self, target):
        """ 
        Gets the estimated times at which we should reach the ERROR state from the OK, WARNING or CRITICAL states.
        The target is the name of the target element (something like server.service)
        All values in the returned structure are in seconds, and contain the period of time to wait between the switch
        Some values may be missing, because they could not be commputed, for example because of a lack of relevant historic data)
        In these cases the returned values are None.
        """
        with self.__opendb() as con:
            if not self.__checktable(con, 'markov'):
                return None
            
            cur = con.cursor()
            cur.execute('SELECT update_time, step, time_from_ok, time_from_warning, time_from_critical FROM markov WHERE probe=?', (target,))
            row = cur.fetchone()
            if row is None:
                return None
            
            result = {
                'date': int(row['update_time']),
                'time_from_ok': int(row['time_from_ok']) * row['step'],
                'time_from_warning': int(row['time_from_warning']) * row['step'],
                'time_from_critical': int(row['time_from_critical']) * row['step'],
            }
            
            if result['time_from_ok'] < 0:
                result['time_from_ok'] = None
            if result['time_from_warning'] < 0:
                result['time_from_warning'] = None
            if result['time_from_critical'] < 0:
                result['time_from_critical'] = None

            return result
            
    def changes_to_error_available(self):
        return self.__checkavailability('markov')
            
    def changepoints(self, target, check = False):
        """
        Gets the positions in time at which changepoints were detected in the specified target
        
        The target argument should contain the name of a Graphite component
        
        If the specified target was never processed by the prediction engine, or does not exist, the function returns None
        Otherwise, the function returns a dict, containing a 'date' key (with the timestamp at which the result was generated)
        a 'checked' key (containing a boolean telling whether the value was previously checked), and a 'values' key containing
        an array of timestamp at which changes were detected. If no changes were detected at all the array is empty.
        """
        with self.__opendb() as con:
            if not self.__checktable(con, 'changepoint'):
                return None
                
            cur = con.cursor()
            cur.execute('SELECT update_time, points, checked FROM changepoint WHERE probe=?', (target,))
            row = cur.fetchone()
            if row is None:
                return None
            
            result = {
                'date': int(row['update_time']),
                'checked': int(row['checked']) == 1,
                'values': []
            }
            
            points = row['points']
            if points is not None and len(points) > 0:
                result['values'] = [int(i) for i in row['points'].split(';')]
            
            if check and not result['checked']:
                cur.execute('UPDATE changepoint SET checked=1 WHERE probe=?', (target,))
                
            return result
            
    def changepoints_available(self):
        return self.__checkavailability('changepoint')
